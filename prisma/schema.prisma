generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id             String           @id @default(uuid())
  email          String           @unique
  name           String?
  password       String?
  role           Role             @default(USER)
  isActive       Boolean          @default(true)
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  googleId       String?          @unique
  avatar         String?
  authProvider   AuthProvider     @default(LOCAL)
  refresh_tokens refresh_tokens[]
  students       students?
  tutors         tutors?
  ai_chat_sessions ai_chat_sessions[]

  @@map("users")
}

model Course {
  id          String        @id @default(uuid())
  title       String
  description String?
  price       Float         @default(0)
  isPublished Boolean       @default(false)
  tutorId     String
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  tutors      tutors        @relation(fields: [tutorId], references: [id])
  enrollments enrollments[]

  @@map("courses")
}

model conversations {
  id        String             @id
  studentId String
  tutorId   String?
  subject   Subject            @default(GENERAL)
  topic     String?
  keywords  String[]           @default([])
  urgency   Urgency            @default(NORMAL)
  status    ConversationStatus @default(PENDING)
  createdAt DateTime           @default(now())
  updatedAt DateTime
  
  // Sharing feature
  isShared    Boolean   @default(false)
  shareToken  String?   @unique  // Unique token for sharing
  sharedAt    DateTime?
  sharedBy    String?   // User ID who shared
  
  students      students        @relation(fields: [studentId], references: [id], onDelete: Cascade)
  tutors        tutors?         @relation(fields: [tutorId], references: [id])
  messages      messages[]
  call_logs     call_logs[]
  waiting_queue waiting_queue?
}

model enrollments {
  id         String           @id
  studentId  String
  courseId   String
  enrolledAt DateTime         @default(now())
  status     EnrollmentStatus @default(ACTIVE)
  courses    Course           @relation(fields: [courseId], references: [id])
  students   students         @relation(fields: [studentId], references: [id])

  @@unique([studentId, courseId])
}

model messages {
  id             String        @id
  conversationId String
  senderId       String
  senderType     SenderType
  content        String?
  messageType    MessageType   @default(TEXT)
  audioUrl       String?
  audioDuration  Int?
  transcription  String?
  attachments    Json?         // Array of { url: string, name: string, type: string, size: number }
  isRead         Boolean       @default(false)
  createdAt      DateTime      @default(now())
  
  // Reaction counts (denormalized for performance)
  likeCount      Int           @default(0)
  dislikeCount   Int           @default(0)
  
  conversations  conversations @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  reactions      message_reactions[]
}

// Message reactions (like/dislike)
model message_reactions {
  id        String       @id @default(uuid())
  messageId String
  userId    String
  type      ReactionType
  createdAt DateTime     @default(now())
  
  messages  messages     @relation(fields: [messageId], references: [id], onDelete: Cascade)
  
  @@unique([messageId, userId])  // One reaction per user per message
  @@index([messageId])
  @@index([userId])
}

enum ReactionType {
  LIKE
  DISLIKE
}

model refresh_tokens {
  id        String   @id
  token     String   @unique
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())
  users     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model students {
  id            String          @id
  userId        String          @unique
  
  // Basic Info
  grade         String?
  school        String?
  phoneNumber   String?
  dateOfBirth   DateTime?
  
  // Parent/Guardian Info
  parentName    String?
  parentEmail   String?
  parentPhone   String?
  
  // Location
  address       String?
  city          String?
  state         String?
  country       String?
  timezone      String?
  
  // Academic Preferences
  preferredSubjects Subject[]   @default([])
  learningGoals     String?
  academicLevel     String?     // e.g., "High School", "Undergraduate", "Graduate"
  
  // Profile Completion
  profileCompleted  Boolean     @default(false)
  
  createdAt     DateTime        @default(now())
  updatedAt     DateTime
  conversations conversations[]
  enrollments   enrollments[]
  users         User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  tutor_sessions tutor_sessions[]
}

model tutors {
  id            String          @id
  userId        String          @unique
  
  // Basic Info
  bio           String?
  phoneNumber   String?
  dateOfBirth   DateTime?
  
  // Location
  address       String?
  city          String?
  state         String?
  country       String?
  timezone      String?
  
  // Academic Qualifications (JSON array: { institution, degree, field, year, gpa })
  qualification String?                   // Legacy field - kept for compatibility
  academicQualifications Json?            // Array of academic qualifications
  
  // Teaching Info
  experience    Int?            @default(0)  // Years of experience
  hourlyRate    Float?
  subjects      Subject[]       @default([])
  areasOfExpertise String?                 // Detailed expertise description
  teachingPhilosophy String?
  teachingStyle String?                    // e.g., "Interactive", "Lecture-based", "Project-based"
  
  // Certifications (JSON array: { name, issuedBy, issuedDate, expiryDate, url, verified })
  certificates  Json?
  
  // Work & Research Experience (JSON array: { company, role, startDate, endDate, description, type })
  workExperience    Json?
  researchExperience String?
  publications      String?               // Notable publications
  
  // Professional Info
  linkedinUrl   String?
  websiteUrl    String?
  languages     String[]        @default([])  // Languages spoken
  
  // Availability
  isAvailable   Boolean         @default(true)
  isBusy        Boolean         @default(false)
  busyUntil     DateTime?
  currentConversationId String?
  availabilitySchedule Json?              // { monday: [{start, end}], tuesday: [...], ... }
  
  // Stats & Ratings
  rating        Float?          @default(0)
  totalReviews  Int             @default(0)
  totalStudentsTaught Int       @default(0)
  totalSessionsCompleted Int    @default(0)
  totalHoursTaught Float        @default(0)
  
  // Verification
  isVerified    Boolean         @default(false)
  verifiedAt    DateTime?
  profileCompleted Boolean      @default(false)
  
  // Bank/Payment Info (for payouts) - encrypted in production
  bankAccountNumber String?
  bankName          String?
  bankRoutingNumber String?
  
  createdAt     DateTime        @default(now())
  updatedAt     DateTime
  conversations conversations[]
  courses       Course[]
  users         User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  tutor_availability_responses tutor_availability_responses[]
  tutor_sessions tutor_sessions[]
}

// Pending tutor notifications for smart routing
model tutor_notifications {
  id             String   @id @default(uuid())
  conversationId String
  tutorId        String
  status         NotificationStatus @default(PENDING)
  sentAt         DateTime @default(now())
  respondedAt    DateTime?
  wave           Int      @default(1) // Which wave of notifications (1st, 2nd, 3rd...)
  createdAt      DateTime @default(now())

  @@index([conversationId])
  @@index([tutorId])
}

// Call logs for tracking audio/video calls
model call_logs {
  id             String      @id @default(uuid())
  conversationId String
  callerId       String      // User ID who initiated the call
  receiverId     String?     // User ID who received the call
  callType       CallType    @default(AUDIO)
  status         CallStatus  @default(INITIATED)
  startedAt      DateTime    @default(now())
  answeredAt     DateTime?
  endedAt        DateTime?
  duration       Int?        // Duration in seconds
  endReason      String?     // Reason for ending (declined, busy, timeout, completed, etc.)
  createdAt      DateTime    @default(now())

  conversations  conversations @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@index([callerId])
  @@index([receiverId])
}

enum CallType {
  AUDIO
  VIDEO
}

enum CallStatus {
  INITIATED
  RINGING
  ANSWERED
  REJECTED
  MISSED
  ENDED
  FAILED
}

enum NotificationStatus {
  PENDING
  ACCEPTED
  REJECTED
  EXPIRED
}

enum Role {
  USER
  ADMIN
  TUTOR
  STUDENT
}

enum AuthProvider {
  LOCAL
  GOOGLE
}

enum ConversationStatus {
  PENDING
  ASSIGNED
  ACTIVE
  RESOLVED
  CLOSED
}

enum EnrollmentStatus {
  ACTIVE
  COMPLETED
  DROPPED
}

enum MessageType {
  TEXT
  AUDIO
  IMAGE
  FILE
}

enum SenderType {
  STUDENT
  TUTOR
  SYSTEM
}

enum Subject {
  MATHEMATICS
  PHYSICS
  CHEMISTRY
  BIOLOGY
  ENGLISH
  HISTORY
  GEOGRAPHY
  COMPUTER_SCIENCE
  ECONOMICS
  ACCOUNTING
  GENERAL
  SOCIAL
  HUMANITIES
  ARTS
}

enum Urgency {
  LOW
  NORMAL
  HIGH
  URGENT
}

enum WaitingQueueStatus {
  WAITING
  TUTORS_NOTIFIED
  AVAILABILITY_COLLECTED
  MATCHED
  EXPIRED
  CANCELLED
}

enum AvailabilityResponseType {
  MINUTES_5
  MINUTES_10
  NOT_ANYTIME_SOON
  CUSTOM
}

// Waiting queue for students waiting more than 2 minutes
model waiting_queue {
  id                  String             @id @default(uuid())
  conversationId      String             @unique
  studentId           String
  subject             Subject
  status              WaitingQueueStatus @default(WAITING)
  waitStartedAt       DateTime           @default(now())
  tutorsNotifiedAt    DateTime?
  shortestWaitMinutes Int?               // Shortest time from all tutor responses
  matchedTutorId      String?
  matchedAt           DateTime?
  expiresAt           DateTime?
  createdAt           DateTime           @default(now())
  updatedAt           DateTime           @updatedAt

  conversations               conversations                  @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  tutor_availability_responses tutor_availability_responses[]

  @@index([studentId])
  @@index([status])
  @@index([subject])
}

// Tutor responses with their availability time
model tutor_availability_responses {
  id              String                   @id @default(uuid())
  waitingQueueId  String
  tutorId         String
  conversationId  String
  responseType    AvailabilityResponseType
  customMinutes   Int?                     // Only for CUSTOM type
  freeAt          DateTime                 // When tutor will be free
  reminderSent    Boolean                  @default(false)
  reminderSentAt  DateTime?
  sessionTaken    Boolean                  @default(false) // If another tutor took it
  createdAt       DateTime                 @default(now())

  waiting_queue waiting_queue @relation(fields: [waitingQueueId], references: [id], onDelete: Cascade)
  tutors        tutors        @relation(fields: [tutorId], references: [id], onDelete: Cascade)

  @@unique([waitingQueueId, tutorId])
  @@index([waitingQueueId])
  @@index([tutorId])
  @@index([conversationId])
  @@index([freeAt])
}

// ============ AI Chat Sessions (Gemini) ============

// AI Chat Session - like a Gemini conversation thread
model ai_chat_sessions {
  id            String              @id @default(uuid())
  userId        String
  title         String?             // Auto-generated or user-set title
  summary       String?             // Brief summary of the conversation
  subject       Subject?            // Detected or user-selected subject
  isArchived    Boolean             @default(false)
  isPinned      Boolean             @default(false)
  lastMessageAt DateTime            @default(now())
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt
  
  // Tutor request tracking
  tutorRequestStatus  TutorRequestStatus?
  tutorRequestedAt    DateTime?
  linkedConversationId String?      // Links to conversations table if tutor connected
  
  // Live sharing with tutor
  liveSharingEnabled  Boolean       @default(false)  // Student consent to share live chat
  liveSharingEnabledAt DateTime?
  
  // Tutor session summary (generated when tutor is requested)
  tutorSummary        String?       // Detailed summary for tutor
  tutorSummaryGeneratedAt DateTime?
  messageSnapshotCount Int?         // Number of messages at summary time
  
  users         User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  ai_messages   ai_messages[]
  tutor_sessions tutor_sessions[]
  
  @@index([userId])
  @@index([lastMessageAt])
  @@index([subject])
}

// AI Message - individual messages in an AI chat session
model ai_messages {
  id              String           @id @default(uuid())
  sessionId       String
  role            AIMessageRole    // USER, ASSISTANT, SYSTEM
  content         String?          // Text content
  
  // Attachments (images, PDFs, audio)
  attachments     Json?            // Array of { url, name, type, size, mimeType }
  audioUrl        String?          // For audio messages
  audioDuration   Int?             // Audio duration in seconds
  transcription   String?          // Transcription of audio
  
  // Response metadata
  isStreaming     Boolean          @default(false)  // Currently streaming
  isComplete      Boolean          @default(true)   // Response complete
  streamId        String?          // For reconnecting to streams
  
  // Error handling
  hasError        Boolean          @default(false)
  errorMessage    String?
  retryCount      Int              @default(0)
  
  // Reactions/feedback
  feedback        AIFeedbackType?  // GOOD, BAD, null
  
  // Token usage for analytics
  promptTokens    Int?
  completionTokens Int?
  
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  
  ai_chat_sessions ai_chat_sessions @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  
  @@index([sessionId])
  @@index([createdAt])
  @@index([role])
}

enum AIMessageRole {
  USER
  ASSISTANT
  SYSTEM
}

enum AIFeedbackType {
  GOOD
  BAD
}

enum TutorRequestStatus {
  NONE
  REQUESTED
  TUTOR_NOTIFIED
  TUTOR_COMING
  TUTOR_CONNECTED
  CANCELLED
}

// Tutor session - when a tutor accepts a student's help request
model tutor_sessions {
  id                  String              @id @default(uuid())
  aiSessionId         String              // Link to ai_chat_sessions
  tutorId             String?             // Tutor profile ID (null until tutor accepts)
  studentId           String              // Student profile ID
  
  // Session status
  status              TutorSessionStatus  @default(PENDING)
  acceptedAt          DateTime?
  startedAt           DateTime?
  endedAt             DateTime?
  
  // Summary and context
  summary             String?             // AI-generated summary of chat
  detectedTopic       String?             // Detected topic from chat
  detectedSubject     Subject?            // Detected subject
  keywords            String[]            @default([])
  
  // Snapshot of messages at request time
  messageSnapshot     Json?               // Array of messages at request time
  snapshotMessageCount Int?
  
  // Live sharing
  liveSharingConsent  Boolean             @default(false)
  liveSharingConsentAt DateTime?
  
  // Daily.co video/audio call
  dailyRoomName       String?             // Daily.co room name
  dailyRoomUrl        String?             // Full room URL
  dailyRoomToken      String?             // Host token for tutor
  callStartedAt       DateTime?
  callEndedAt         DateTime?
  callDuration        Int?                // Duration in seconds

  // Daily.co meeting data (saved when meeting ends)
  dailyChatMessages   Json?               // Array of chat messages from Daily.co
  dailyRecordingUrl   String?             // URL to meeting recording
  dailyParticipants   Json?               // Array of meeting participants
  
  // Excalidraw whiteboard
  whiteboardEnabled   Boolean             @default(false)
  whiteboardData      Json?               // Excalidraw scene data
  whiteboardRoomId    String?             // Collaborative room ID
  
  // Screen sharing
  screenShareEnabled  Boolean             @default(false)
  
  // Session notes
  tutorNotes          String?             // Private notes by tutor
  studentRating       Int?                // 1-5 rating by student
  studentFeedback     String?             // Feedback from student
  
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt
  
  ai_chat_sessions    ai_chat_sessions    @relation(fields: [aiSessionId], references: [id], onDelete: Cascade)
  tutors              tutors?             @relation(fields: [tutorId], references: [id], onDelete: Cascade)
  students            students            @relation(fields: [studentId], references: [id], onDelete: Cascade)
  
  @@index([aiSessionId])
  @@index([tutorId])
  @@index([studentId])
  @@index([status])
}

enum TutorSessionStatus {
  PENDING       // Waiting for tutor to accept
  ACCEPTED      // Tutor accepted, preparing session
  ACTIVE        // Session in progress
  COMPLETED     // Session ended normally
  CANCELLED     // Session cancelled
}
